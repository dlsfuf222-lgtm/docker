## 6.2 메모리 공유 (Sharing memory)

안녕하세요\! 오늘은 \*\*메모리 공유(Memory Sharing)\*\*에 대해 자세히 알아보겠습니다. 리눅스 환경에서는 같은 컴퓨터에서 실행되는 프로그램들이 서로 메모리를 공유할 수 있도록 다양한 도구들을 제공합니다. 이것을 바로 \*\*프로세스 간 통신(Inter-Process Communication, IPC)\*\*이라고 부릅니다. IPC는 프로세스들이 직접 메모리를 통해 데이터를 주고받는 방식이에요.

왜 이런 방식이 중요할까요? 바로 **속도** 때문입니다. 인터넷이나 파이프를 이용하는 통신 방식은 상대적으로 느려서 프로그램의 성능을 저하시킬 수 있지만, 메모리를 공유하면 데이터를 주고받는 속도가 훨씬 빨라집니다. 그래서 과학 계산이나 PostgreSQL 같은 고성능 데이터베이스 기술에서 메모리 기반 IPC를 널리 사용합니다.

-----

### Docker와 IPC 네임스페이스

도커는 컨테이너마다 고유한 **IPC 네임스페이스**를 만듭니다. 🚀 이 네임스페이스는 쉽게 말해, 프로그램들이 공유하는 메모리 영역(공유 메모리 블록, 세마포어, 메시지 큐 등)을 다른 컨테이너와 분리하는 역할을 합니다. 이런 용어가 어렵게 느껴지신다면, 그냥 "여러 프로그램들이 서로 협력하며 작업을 조율할 때 쓰는 도구"라고 생각하시면 됩니다.

이 IPC 네임스페이스 덕분에 컨테이너 안의 프로그램이 호스트 컴퓨터나 다른 컨테이너의 메모리에 함부로 접근할 수 없게 되어, **보안이 훨씬 강력**해집니다. 이는 도커의 핵심적인 보안 기능 중 하나입니다.

-----

### 6.2.1 컨테이너 간 IPC 기본 요소 공유 (Sharing IPC primitives between containers)

자, 이제 직접 실습을 통해 컨테이너 간 메모리 공유가 어떻게 작동하는지 살펴볼까요? intheeast0305/ch6\_ipc 이미지는 \*\*프로듀서(producer)\*\*와 \*\*컨슈머(consumer)\*\*가 모두 포함된 이미지입니다. 이들은 공유 메모리를 통해 통신하도록 설계되었어요.

먼저, 두 컨테이너를 각각 별도로 실행해 보겠습니다.

```bash
# 프로듀서 시작
docker container run -d -u nobody --name ch6_ipc_producer \    
    --ipc shareable \
    intheeast0305/ch6_ipc -producer 
    
# 컨슈머 시작
docker container run -d -u nobody --name ch6_ipc_consumer \   
    intheeast0305/ch6_ipc -consumer
```

첫 번째 컨테이너인 `ch6_ipc_producer`는 메시지 큐를 만들고 메시지를 브로드캐스트하는 역할을 합니다. 두 번째 컨테이너인 `ch6_ipc_consumer`는 메시지 큐에서 메시지를 가져와 로그에 기록해야 합니다. 각 컨테이너의 로그를 확인해볼까요?

```bash
docker logs ch6_ipc_producer
docker logs ch6_ipc_consumer
```

로그를 확인해보면 **문제**가 발생했음을 알 수 있습니다. `ch6_ipc_consumer`는 큐에서 메시지를 전혀 가져오지 못합니다. 😟 왜냐하면 각 컨테이너가 **자신만의 IPC 네임스페이스**를 가지고 있기 때문입니다. 비록 프로듀서와 컨슈머 모두 공유 메모리 리소스를 식별하기 위해 동일한 키를 사용하지만, 그 키가 가리키는 실제 메모리 위치가 서로 다른 IPC 네임스페이스에 존재하기 때문에 통신이 불가능한 거죠.

-----

### `--ipc` 플래그로 IPC 네임스페이스 연결하기

컨테이너 간에 공유 메모리를 사용하려면, `--ipc` 플래그를 사용해 컨테이너들의 IPC 네임스페이스를 연결해줘야 합니다. `--ipc container:[타겟 컨테이너명]` 옵션은 새로운 컨테이너가 타겟 컨테이너와 **동일한 IPC 네임스페이스**를 공유하도록 만듭니다. 이는 제5장에서 다뤘던 `--network` 플래그와 비슷한 원리로 작동합니다.

자, 이제 기존 `ch6_ipc_consumer` 컨테이너를 제거하고, `--ipc` 플래그를 이용해 다시 실행해봅시다.

```bash
# 기존 컨슈머 컨테이너 제거
docker container rm -v ch6_ipc_consumer    

# 새로운 컨슈머 컨테이너 시작 (IPC 네임스페이스 연결)
docker container run -d --name ch6_ipc_consumer \    
    --ipc container:ch6_ipc_producer \       
    intheeast0305/ch6_ipc -consumer
```

위 명령어를 실행하면, `ch6_ipc_consumer`는 `ch6_ipc_producer`와 동일한 IPC 네임스페이스에 참여하게 됩니다. 이제 컨슈머는 프로듀서가 데이터를 쓰고 있는 **동일한 메모리 위치**에 접근할 수 있게 됩니다. 다시 로그를 확인해볼까요?

```bash
docker logs ch6_ipc_producer
docker logs ch6_ipc_consumer
```

보시는 것처럼, 이제 컨슈머 컨테이너의 로그에 프로듀서가 보낸 메시지가 성공적으로 기록되는 것을 확인할 수 있을 거예요. 🥳

-----

### 정리 및 보안 고려사항

실습을 마쳤으니, 다음으로 넘어가기 전에 실행 중인 컨테이너들을 정리하는 것을 잊지 마세요.

```bash
docker rm -vf ch6_ipc_producer ch6_ipc_consumer
```

여기서 `-v` 옵션은 볼륨을 정리하고, `-f` 옵션은 실행 중인 컨테이너를 강제로 종료시키는 역할을 합니다.

컨테이너의 공유 메모리 네임스페이스를 재사용하는 것은 **보안에 명백한 영향**을 미칩니다. 그러나 컨테이너 간에 통신이 꼭 필요할 경우, 이 옵션은 매우 유용합니다. 특히 **호스트와 메모리를 공유하는 것보다 훨씬 안전한 대안**이 될 수 있습니다. 호스트와 메모리를 공유하는 `--ipc=host` 옵션도 있지만, 이는 도커의 기본 보안 정책과 충돌하기 때문에 최신 도커 배포판에서는 권장되지 않습니다.

오늘 강의의 예제 코드는 간단한 C 프로그램으로 작성되었으며, Docker Hub의 이미지 페이지에서 소스 저장소 링크를 통해 직접 확인하실 수 있습니다. 직접 코드를 보며 공유 메모리가 어떻게 구현되는지 이해하시면 더욱 도움이 될 거예요.

오늘 다룬 내용, 어떠셨나요? 컨테이너 간 통신과 IPC 네임스페이스의 개념이 잘 이해되셨기를 바랍니다. 다음 시간에는 더 흥미로운 내용으로 찾아뵙겠습니다\!
