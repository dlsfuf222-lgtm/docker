이번 시간에는 **도커 컨테이너 네트워킹**에 대해 강의를 진행하겠습니다. 

-----

### **5.2 도커 컨테이너 네트워킹**

#### **도커 컨테이너 네트워킹의 작동 원리**

도커 네트워킹의 가장 핵심적인 원리는 컨테이너와 호스트의 네트워크를 분리하는 데 있습니다. 이를 \*\*'런타임 환경 불가지론(Runtime Environment Agnostic)'\*\*이라고 부릅니다. 이 철학 덕분에 개발자는 네트워크 설정에 얽매이지 않고 애플리케이션 개발에만 집중할 수 있고, 운영자는 필요에 따라 컨테이너의 네트워크를 유연하게 관리할 수 있습니다.

도커 네트워크에 연결된 컨테이너는 고유한 IP 주소를 부여받아 같은 네트워크에 있는 다른 컨테이너와 통신할 수 있습니다. 이 과정은 다음과 같이 이루어집니다.

  * **네트워크 생성**: 도커는 컨테이너를 실행하기 위해 가상의 네트워크를 직접 만들 수 있는 기능을 제공합니다. 이 네트워크는 일종의 독립적인 통신 공간을 형성합니다.
  * **IP 주소 할당**: 컨테이너가 이 네트워크에 연결되면, 도커는 미리 정의된 IP 주소 범위 내에서 컨테이너에 고유한 사설(private) IP를 할당합니다.
  * **컨테이너 간 통신**: 컨테이너가 다른 컨테이너로 데이터를 보낼 때, 도커 네트워크는 이 통신을 내부적으로 라우팅하여 올바른 목적지로 전달합니다. 이 모든 과정이 컨테이너 내부에서는 투명하게 이루어집니다.
  * **네트워크 격리**: 각 도커 네트워크는 서로 독립적입니다. 따라서 별도의 연결 설정을 하지 않으면, 다른 네트워크에 속한 컨테이너끼리는 직접 통신할 수 없습니다. 이는 컨테이너 환경의 보안을 강화하는 중요한 요소입니다.

이처럼 도커 네트워킹은 컨테이너 애플리케이션의 통신을 간편하면서도 안전하게 만들어주는 기반 기술입니다.

#### **네트워킹의 주요 과제**

하지만 이 방식에는 한 가지 도전 과제가 있습니다. 컨테이너 내부의 애플리케이션은 자신이 실행되는 호스트의 실제 IP 주소나 포트를 직접 알지 못합니다. 이 때문에 컨테이너가 외부에 있는 서비스(예: 웹 브라우저)에게 자신의 위치를 알리기가 어렵습니다. 이 문제는 \*\*포트 퍼블리싱(Port Publishing)\*\*과 같은 추가적인 설정을 통해 해결할 수 있으며, 이 내용은 추후에 더 자세히 다루겠습니다.

도커에서 네트워크는 컨테이너와는 별개로 생성, 관리, 제거될 수 있는 **독립적인 객체**로 취급됩니다. `docker network ls` 명령어를 사용하면 현재 시스템에 존재하는 모든 네트워크 목록을 확인할 수 있습니다.

```bash
$ docker network ls
NETWORK ID       NAME     DRIVER     SCOPE
63d93214524b     bridge   bridge     local
6eeb489baff0     host     host       local
3254d02034ed     none     null       local
```

도커는 디폴트로 세 가지 네트워크를 제공하며, 각각 다른 드라이버를 통해 구현됩니다.

  * **bridge**: `bridge` 드라이버를 사용하며, 동일한 컴퓨터에서 실행되는 모든 컨테이너 간의 연결을 제공하는 **기본 네트워크**입니다. 별도로 네트워크를 지정하지 않으면 컨테이너는 이 네트워크에 연결됩니다.
  * **host**: `host` 드라이버를 사용하며, 컨테이너를 위해 별도의 네트워크 환경을 만들지 않고, 컨테이너가 호스트(컴퓨터)의 네트워크 스택과 직접 소통하게 합니다. 이는 속도 이점을 제공하지만, 격리라는 도커의 장점을 일부 포기하는 것입니다.
  * **none**: `null` 드라이버를 사용하며, 이 네트워크에 연결된 컨테이너는 외부와의 네트워크 연결이 완전히 끊어집니다. 보안이 중요한 경우나 외부 통신이 불필요한 경우에 사용됩니다.

네트워크의 \*\*범위(Scope)\*\*는 `local`, `global`, `swarm` 세 가지 중 하나입니다. 디폴트 네트워크는 모두 `local` 범위를 가지므로, 다른 컴퓨터에서 실행되는 컨테이너와는 직접 통신할 수 없습니다.

#### **디폴트 브리지 네트워크의 한계**

디폴트 `bridge` 네트워크는 이전 버전과의 호환성을 위해 존재하며, 최신 도커의 **서비스 디스커버리**나 **로드 밸런싱**과 같은 기능을 활용할 수 없습니다. 따라서 이 네트워크를 그대로 사용하는 것은 권장되지 않습니다. 가장 먼저 해야 할 일은 **자신만의 브리지 네트워크를 만드는 것**입니다.

-----

### **5.2.1 사용자 정의 브리지 네트워크 생성하기**

도커의 브리지 네트워크 드라이버는 리눅스 네임스페이스, 가상 이더넷 장치, 그리고 리눅스 방화벽과 같은 기술을 활용하여 \*\*'브리지(Bridge)'\*\*라는 가상 네트워크를 만듭니다. 이 가상 네트워크는 도커가 설치된 컴퓨터 내부에 존재하며, 네트워크에 참여하는 컨테이너와 컨테이너가 실행되는 호스트 컴퓨터의 실제 네트워크를 연결하는 경로 역할을 합니다.

위 **그림 5.4**는 브리지 네트워크와 여기에 연결된 두 개의 컨테이너 및 그 구성 요소들을 보여줍니다.

  * **컨테이너 내부**: 각 컨테이너는 **자체적인 프라이빗 인터페이스**와 **루프백 인터페이스**를 가집니다. 루프백 인터페이스는 컨테이너 내부에서만 사용되며(127.0.0.1), 프라이빗 인터페이스는 격리된 통신을 위한 내부 통로입니다.
  * **호스트와 컨테이너의 연결**: 컨테이너의 프라이빗 인터페이스는 호스트의 네임스페이스에 연결된 **가상 이더넷 인터페이스**를 통해 호스트 네트워크와 소통합니다.
  * **가상 브리지 (`docker0`)**: 이 가상 브리지는 여러 컨테이너의 가상 이더넷 인터페이스들을 서로 연결하는 스위치 역할을 합니다.
  * **네트워크의 최종 연결**: `docker0` 브리지는 **논리적 호스트 인터페이스**를 통해 **물리적 네트워크 인터페이스**와 연결되어 최종적으로 외부 네트워크와 통신할 수 있게 됩니다.

이러한 구조 덕분에 각 컨테이너는 고유한 사설 IP를 할당받고, 컨테이너 간의 트래픽은 이 가상 브리지를 통해 라우팅됩니다.

이제 싱글 커맨드로 새로운 사용자 정의 네트워크를 만들어 보겠습니다.

```bash
docker network create \
 --driver bridge \
 --label project=dockerinaction \
 --label chapter=5 \
 --attachable \
 --scope local \
 --subnet 10.0.42.0/24 \
 --ip-range 10.0.42.128/25 \
 user-network
```

이 명령어는 `user-network`라는 이름의 새로운 로컬 브리지 네트워크를 생성합니다. 각 옵션의 의미는 다음과 같습니다.

  * `--driver bridge`: 이 네트워크가 브리지 드라이버를 사용하도록 지정합니다.
  * `--label ...`: 네트워크에 메타데이터(라벨)를 추가하여 관리 편의성을 높입니다.
  * `--attachable`: 이 옵션을 사용하면 실행 중인 컨테이너를 이 네트워크에 자유롭게 연결하거나 분리할 수 있습니다.
  * `--scope local`: 네트워크의 범위를 현재 도커 호스트로 한정합니다.
  * `--subnet 10.0.42.0/24`: 네트워크가 사용할 **전체 IP 주소 범위**를 정의합니다.
  * `--ip-range 10.0.42.128/25`: 컨테이너에 **실제로 할당할 IP 주소의 범위**를 지정합니다. 이 범위는 전체 서브넷의 절반입니다.

결론적으로, 이 명령어로 `user-network`를 만들면 이 네트워크에 연결되는 모든 컨테이너는 10.0.42.128부터 10.0.42.255 사이의 IP 주소를 자동으로 할당받게 됩니다.

-----

### **5.2.2 브리지 네트워크 탐색하기**

이제 실제로 컨테이너를 만들고, 그 내부에서 네트워크 환경이 어떻게 구성되는지 알아보겠습니다.

#### **컨테이너의 초기 네트워크 상태 확인**

다음 명령어를 실행하여 `network-explorer`라는 이름의 컨테이너를 만들고, `user-network`에 연결합니다.

```bash
docker run -it \
 --network user-network \
 --name network-explorer \
 alpine:latest \
 sh
```

컨테이너 내부 터미널에서 `ip -f inet -4 -o addr` 명령어를 실행하여 IPv4 주소 목록을 확인하세요.

```
1: lo inet 127.0.0.1/8 scope host lo\ ...
18: eth0 inet 10.0.42.129/24 brd 10.0.42.255 scope global eth0\ ...
```

이 결과를 보면, 컨테이너에는 두 개의 네트워크 인터페이스가 있다는 것을 알 수 있습니다.

  * **`lo`**: 127.0.0.1 주소를 가진 **루프백 인터페이스**로, 컨테이너 내부에서만 사용됩니다.
  * **`eth0`**: 10.0.42.129 주소를 가진 **가상 이더넷 인터페이스**입니다. 이 주소는 이전에 설정한 `user-network`의 IP 범위(10.0.42.128 \~ 10.0.42.255)에 속합니다. 이 주소를 통해 `user-network`에 연결된 다른 컨테이너들과 통신할 수 있습니다.

#### **두 번째 네트워크에 컨테이너 연결하기**

이제 실행 중인 `network-explorer` 컨테이너를 다른 네트워크에도 연결해 보겠습니다.

1.  **터미널 분리**: 컨테이너를 정지하지 않고 터미널에서 나오려면 `Ctrl-P`를 누른 후 `Ctrl-Q`를 누르세요.
2.  **새로운 네트워크 만들기**: `user-network2`라는 두 번째 브리지 네트워크를 만듭니다.
    ```bash
    docker network create \
     --driver bridge \
     --label project=dockerinaction \
     --label chapter=5 \
     --attachable \
     --scope local \
     --subnet 10.0.43.0/24 \
     --ip-range 10.0.43.128/25 \
     user-network2
    ```
3.  **컨테이너 연결하기**: `docker network connect` 명령어를 사용하여 실행 중인 컨테이너를 방금 만든 `user-network2`에 연결합니다.
    ```bash
    docker network connect \
     user-network2 \ 
     network-explorer
    ```
4.  **네트워크 상태 다시 확인하기**: 컨테이너에 다시 접속하려면 `docker attach network-explorer`를 사용합니다. 컨테이너 내부에서 다시 `ip -f inet -4 -o addr` 명령어를 실행하면 다음과 같은 결과를 볼 수 있습니다.

<!-- end list -->

```
1: lo inet 127.0.0.1/8 scope host lo\ ...
18: eth0 inet 10.0.42.129/24 brd 10.0.42.255 scope global eth0\ ...
20: eth1 inet 10.0.43.129/24 brd 10.0.43.255 scope global eth1\ ...
```

예상대로 `eth1`이라는 새로운 인터페이스가 추가된 것을 확인할 수 있습니다. 이 인터페이스는 `user-network2`의 IP 범위에 속하는 10.0.43.129 주소를 할당받았습니다. 이로써 `network-explorer` 컨테이너가 **두 개의 네트워크에 동시에 연결**되었음을 명확하게 알 수 있습니다.

-----

### **5.2.3 Beyond bridge networks**

사용 사례에 따라 브리지 네트워크만으로 충분할 수 있습니다. 예를 들어, 한 대의 서버에서 콘텐츠 관리 시스템(CMS)이나 로컬 개발 작업을 할 때는 브리지 네트워크가 가장 좋은 선택입니다.

하지만 여러 대의 서버로 구성된 환경(멀티서버 환경)에서는 브리지 네트워크의 `local` 범위 한계 때문에 다른 네트워크 옵션이 필요합니다.

#### **언더레이(Underlay) 네트워크: Macvlan & IPvlan**

  * **언제 사용?**: Linux 호스트를 사용하고 있고, 호스트의 네트워크 설정을 직접 제어할 수 있을 때 적합합니다.
  * **어떻게 작동?**: `macvlan`이나 `ipvlan` 드라이버를 사용하면, 각 컨테이너는 마치 물리적인 네트워크에 직접 연결된 것처럼 **고유한 IP 주소**를 갖게 됩니다. 이 IP 주소는 호스트가 연결된 네트워크에서 바로 인식되고 라우팅될 수 있습니다. 즉, 각 컨테이너가 네트워크상의 독립적인 장치처럼 보입니다.
  * **단점**: macOS나 Windows에서는 사용할 수 없으며, 네트워크 설정이 호스트 환경에 종속되어 유연성이 떨어집니다.

#### **오버레이(Overlay) 네트워크**

  * **언제 사용?**: 여러 대의 서버에 걸쳐 컨테이너들을 연결해야 하는 **멀티서버 환경**에서 가장 많이 사용되는 옵션입니다.
  * **어떻게 작동?**: \*\*스웜 모드(Swarm Mode)\*\*가 활성화된 도커에서 사용할 수 있으며, 여러 호스트를 마치 하나의 거대한 네트워크처럼 연결합니다. 브리지 네트워크와 비슷하게 논리적인 네트워크를 만들지만, 이 네트워크는 여러 호스트에 걸쳐 컨테이너 간 통신을 라우팅할 수 있습니다.
  * **특징**:
      * 컨테이너들은 클러스터 외부에서 직접 접근할 수 없습니다.
      * 컨테이너 간 통신이 매우 간단합니다.
      * 네트워크 설정이 대부분 호스트 환경과 독립적이어서 유연성이 높습니다.

#### **특수한 네트워크 요구 사항**

만약 위 두 가지 네트워크로 해결되지 않는 복잡한 요구사항이 있다면, 도커는 호스트 네트워크를 직접 사용하거나 컨테이너를 완벽히 격리하는 등 특수한 네트워크 옵션도 제공합니다.

오늘 강의를 통해 도커 네트워킹의 기본 원리와 다양한 네트워크 옵션에 대해 깊이 있는 이해를 얻으셨기를 바랍니다.
