
# 리눅스의 `fork()` 시스템 호출 🐧

---

## 1. `fork()`란?

리눅스에서 `fork()`는 **현재 실행 중인 프로세스를 복제하여 새로운 프로세스를 생성하는 시스템 호출**입니다.

* 원래 있던 프로세스 = **부모 프로세스(Parent Process)**
* 새로 생성된 프로세스 = **자식 프로세스(Child Process)**

👉 즉, `fork()`를 호출하면 **프로세스가 두 개로 나뉘어 동시에 실행**됩니다.

---

## 2. 동작 방식

`fork()` 호출 시 커널은 다음을 수행합니다:

1. 부모 프로세스의 주소 공간을 **복제(Copy-on-Write)**

   * 코드, 데이터, 스택 등을 그대로 “참조”
   * 실제 복사는 쓰기 동작이 발생할 때 일어남 → 성능 최적화
2. 자식 프로세스는 새로운 **PID(Process ID)** 를 부여받음
3. 파일 디스크립터, 환경 변수 등은 부모와 동일하게 상속
4. 부모/자식은 **fork 호출 직후부터 동일한 코드**를 실행하지만, **리턴값(return value)** 이 다름

---

## 3. 반환 값(return value)

* 부모 프로세스에서: `fork()`는 **자식의 PID** 반환
* 자식 프로세스에서: `fork()`는 **0** 반환
* 오류 발생 시: **-1** 반환 (프로세스 생성 실패)

👉 따라서 **리턴값을 조건문으로 구분**하여 부모/자식의 실행 흐름을 나눌 수 있습니다.

---

## 4. 예제 코드

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        // 오류 발생
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // 자식 프로세스
        printf("Hello from Child! PID=%d, Parent PID=%d\n", getpid(), getppid());
    } else {
        // 부모 프로세스
        printf("Hello from Parent! PID=%d, Child PID=%d\n", getpid(), pid);
    }

    return 0;
}
```

### 실행 예시

```
Hello from Parent! PID=1234, Child PID=1235
Hello from Child! PID=1235, Parent PID=1234
```

---

## 5. 활용 사례

* **멀티프로세싱**: 서버 프로그램에서 여러 클라이언트를 동시에 처리
* **데몬 생성**: 백그라운드 서비스 실행 시 `fork()` 사용
* **UNIX 파이프라인**: `ls | grep txt` 같은 파이프라인은 내부적으로 `fork()` + `exec()` 조합으로 동작
* **프로세스 제어 실습**: 운영체제 수업에서 가장 먼저 배우는 실험 주제

---

## 6. 주의할 점

1. **좀비 프로세스(Zombie Process)**

   * 자식 프로세스가 종료되었지만 부모가 `wait()` 하지 않으면 PCB가 남아 좀비 상태 발생
   * 해결: 부모가 `wait()` 또는 `waitpid()` 호출해야 함

2. **고아 프로세스(Orphan Process)**

   * 부모 프로세스가 먼저 종료되면 자식은 `init`(PID 1) 프로세스가 대신 관리

3. **리소스 낭비**

   * 과도한 `fork()` 호출은 시스템 부하 초래 (예: fork bomb `:(){ :|:& };:`)

---

## 7. 정리

* `fork()` = **현재 프로세스를 복제**하여 새로운 프로세스를 만드는 시스템 호출
* 부모와 자식은 같은 코드 실행, 하지만 **리턴값**으로 구분 가능
* 프로세스 관리의 핵심: `fork()` + `exec()` + `wait()` 조합
* 멀티프로세스 프로그래밍, 서버, 데몬 구현에서 핵심 역할

