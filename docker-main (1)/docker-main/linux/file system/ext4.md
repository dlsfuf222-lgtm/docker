# ext4 파일시스템

아래는 \*\*리눅스에서 가장 널리 쓰이는 일반 목적 파일시스템(ext4)\*\*를, 내부 구조(온디스크 레이아웃)부터 디렉터리/인덱스 구조, 저널링, 성능/일관성 기법, 마운트/도구 사용법까지 “계층적으로” 풀어낸 설명입니다.
(※ 여기서 말하는 “계층구조”는 두 가지를 모두 다룹니다: 1) **ext4의 온디스크 계층**과 2) **리눅스의 디렉터리 계층(FHS)**.)

---

## 1) 큰 그림: 블록장치 → 파티션 → ext4

* **블록장치**: `/dev/sda`, `/dev/nvme0n1` 같은 물리/가상 디스크.
* **파티션**: `/dev/sda1` 같은 구획. (GPT의 경우 `0x8300` 타입 등이 리눅스 파일시스템 용도)
* **파일시스템(ext4)**: 파티션 위에 `mkfs.ext4`로 생성. 이후 `mount`를 통해 \*\*리눅스 단일 트리(/)\*\*에 붙입니다.

---

## 2) ext4 온디스크 “계층구조”(레이어별 구조)

### A. 슈퍼블록(Superblock)

* **위치**: 장치/파티션의 **바이트 오프셋 1024**에서 시작하는 고정 크기 구조체.
* **역할**: 파일시스템의 “메타데이터 헤더”. 블록 크기, 전체 블록 수, 자유 블록/아이노드 수, 기능 플래그(저널링/체크섬 등), 타임스탬프 기능 등 **전체 설정을 통제**.
* **매직 넘버**: `0xEF53` (슈퍼블록 내 오프셋 0x38).
  → OS/도구가 이 값을 읽고 “이건 ext 계열이야(보통 ext4)”라고 **자동 인식**합니다.
* **백업 슈퍼블록**: 일부 **블록그룹**에 **백업본**을 둠.

  * `sparse_super` 기능: 선택된 그룹(전통적으로 1과 3·5·7의 거듭제곱 계열 등)에만 백업 저장
  * `sparse_super2` 기능: 더 적은 수의 백업(예: 그룹 1과 마지막 그룹 등)로 축소

> 직접 확인 예시
>
> ```bash
> sudo dd if=/dev/sdX1 bs=1024 skip=1 count=1 | hexdump -C | head
> # 슈퍼블록(1024바이트) 덤프
> # 매직(0xEF53)은 슈퍼블록 시작 기준 0x38(56바이트) 위치에 존재
> ```
>
> ```bash
> sudo blkid /dev/sdX1      # FS 타입/UUID 자동 인식
> sudo dumpe2fs -h /dev/sdX1 # 슈퍼블록 요약
> sudo tune2fs -l /dev/sdX1  # 기능 플래그/설정 상세
> ```

### B. 블록그룹(Block Group) & 그룹 디스크립터

* ext4는 \*\*전체 공간을 여러 “블록그룹”\*\*으로 나누어 관리(지역성↑, 단편화↓).
* 각 블록그룹에 보통 다음 **하위 구조**가 있습니다:

  1. **블록 비트맵**: 이 그룹에서 **어떤 블록이 사용/비어 있는지** 표시
  2. **아이노드 비트맵**: 이 그룹의 **아이노드 사용 현황**
  3. **아이노드 테이블**: 실제 아이노드(파일 메타데이터)들이 연속 저장
  4. **데이터 블록 영역**: 파일/디렉터리/인덱스/저널(내장형일 때 일부) 등 **실데이터**
* **그룹 디스크립터 테이블**: 각 블록그룹의 메타를 모은 목록(어디에 비트맵/아이노드 테이블이 있는지 등).
  `meta_bg`, `flex_bg` 기능을 통해 디스크립터/아이노드 테이블을 더 유연하게 배치, 여러 그룹을 묶어(플렉스 그룹) **할당·탐색 효율**을 높입니다.

### C. 아이노드(Inode)

* **파일/디렉터리의 메타데이터**(소유자/권한/타임스탬프/링크수/확장속성 등)를 담는 레코드.
* 아이노드는 \*\*파일 내용(데이터 블록 위치)\*\*를 직접 가지지 않고, \*\*“익스텐트(Extent) 트리”\*\*를 통해 간접 참조(아래 D 참조).
* **특수 아이노드**(일부 예):

  * `#2`: **루트 디렉터리**
  * `#7`: 리사이즈용
  * `#8`: **저널(internal journal) 아이노드**
* **Inline Data** 기능: 아주 작은 파일은 **아이노드 내부**에 데이터(일부 바이트)를 직접 담아 I/O 절감.

### D. 익스텐트(Extent) 트리 (ext4의 핵심)

* ext2/3의 “블록 맵(간접/이중간접 포인터)” 대신 ext4는 **Extent**(연속 블록 구간) 기반.
* 구조: **루트(아이노드 내 헤더)** → 필요 시 **내부 노드** → **리프 노드(실제 \[시작블록, 길이])**

  * 큰 파일도 **연속 구간 단위**로 관리해 **랜덤 I/O·단편화**를 줄임.
* 실제 배치 확인 예:

  ```bash
  filefrag -v some-big-file      # 익스텐트와 배치 확인
  debugfs -R 'stat <inode번호>' /dev/sdX1
  ```

### E. 디렉터리 & HTree(해시 B-트리 인덱스)

* **디렉터리 엔트리**는 “이름 → 아이노드번호” 매핑의 **가변 길이 레코드**(inode, rec\_len, name\_len, file\_type, name…).
* 큰 디렉터리의 탐색 성능을 위해 **htree(해시 트리)** 인덱싱(`dir_index` 기능) 사용:

  * **1\~2단계 B-트리** 형태 + 이름 해싱
  * 수많은 파일이 있는 디렉터리에서도 **O(log N)에 가까운 탐색** 성능 제공.

### F. 저널링(JBD2) 계층

* ext4의 저널은 **JBD2 레이어**가 관리.
* **모드**(mount 옵션 `data=`):

  * `ordered`(기본): **데이터**는 먼저 본 위치에 기록된 뒤 **메타데이터만 저널**에 커밋 → **일관성↑, 속도/안정성 밸런스**
  * `writeback`: 메타데이터만 저널, **데이터 순서 보장 X** → 빠르지만 크래시 시 **stale 데이터 노출 위험↑**
  * `journal`: **데이터+메타데이터 모두 저널** → 가장 안전하지만 느릴 수 있음
* **내장 저널**(일반적: 저널 아이노드 `#8`) vs **외장 저널 장치**(별도 블록장치에 두어 I/O 병렬성↑)
* **체크섬**, **배리어/flush**, **commit 주기** 등으로 내구성 보강

---

## 3) 성능·신뢰성 기능(하이라이트)

* **지연 할당(Delayed Allocation)**: 실제 블록 할당을 쓰기 시점에 늦춰 **연속성↑, 단편화↓**
* **멀티블록 할당기(mballoc)**: 큰 연속 구간을 한 번에 할당
* **프리할로케이션(fallocate)**: 파일 공간을 **미리** 연속으로 예약
* \*\*메타데이터 체크섬(`metadata_csum`)\*\*과 **그룹 초기화 지연(`uninit_bg`)**: fsck 속도·정확성 개선
* **64비트 주소(`64bit`)**, **huge\_file**, **bigalloc(클러스터 단위 할당)** 등 대용량 친화
* **암호화(fscrypt)**: 디렉터리(트리) 단위 투명 암호화
* **casefold(디렉터리별 대소문자 무시)**: `-O casefold`로 활성화 후 해당 디렉터리에 속성 부여
* **Quota**: `usrquota`, `grpquota`, `prjquota(프로젝트 쿼터)` 지원
* **타임스탬프**: `lazytime`, `bigtime`(Y2038 대비) 등

> 참고로 ext4는 설계상 **아주 큰 파일시스템/파일**을 지원합니다(이론치가 매우 큼).
> 실제 한계는 **커널, e2fsprogs, 블록 크기, 64bit 옵션 사용 여부** 등 환경에 따라 달라집니다.

---

## 4) 리눅스의 **디렉터리 계층(FHS)** vs ext4 내부

* **FHS(파일시스템 계층 표준)**: `/`를 루트로 한 **논리적 계층**.

  * 예: `/bin`, `/sbin`, `/usr`, `/var`, `/home`, `/etc`, `/lib`, `/opt`, `/mnt`, `/media` …
  * \*\*여러 파일시스템(ext4/xfs/btrfs/…)\*\*이 **마운트**되어 **하나의 트리**로 보임.
* **ext4 내부 계층**: 위의 **슈퍼블록 → 블록그룹 → (비트맵/아이노드테이블/데이터블록) → 아이노드 → 익스텐트/디렉터리** 구조.
  즉, **FHS는 논리적 트리**, **ext4는 물리/메타데이터 배치**의 계층.

---

## 5) 파일/디렉터리 동작의 정밀 포인트

### 하드링크/심볼릭링크

* **하드링크**: **같은 아이노드**에 **다른 이름**(링크카운트 증가). 같은 파일시스템 내부에서만 가능.
* **심링크**: 별도 아이노드가 **경로 문자열을 데이터**로 가짐(작으면 아이노드에 인라인).

### 권한·확장속성·SELinux/ACL

* **권한/소유자**: 전통적 POSIX 모드 + UID/GID
* **ACL**: `setfacl/getfacl`로 **세밀한 권한**
* **확장속성(xattr)**: `user.`, `security.`, `system.`, `trusted.` 네임스페이스
  → SELinux 컨텍스트, 캡처된 메타데이터, 사용자 메모 등 저장
* **파일 속성(chattr/lsattr)**: `+i`(immutable), `+a`(append-only), `+E`(extents), `+F`(casefold dir) 등

  ```bash
  lsattr path
  sudo chattr +i critical.conf   # 삭제/변경 불가
  sudo chattr -i critical.conf
  ```

---

## 6) 마운트/옵션/일상 운용

### 마운트 & 확인

```bash
sudo mount -t ext4 /dev/sdX1 /mnt
findmnt /mnt
stat -f -c '%T' /mnt   # 파일시스템 타입 표시 (ex: ext2/ext3)
lsblk -f               # 파티션별 FS/UUID/라벨
```

### 자주 쓰는 마운트 옵션(일부)

* `data=ordered|writeback|journal` (저널링 모드)
* `noatime`, `relatime`, `lazytime`
* `discard`(실시간 TRIM), `fstrim`(주기적 TRIM)
* `commit=`, `journal_checksum`, `barrier`(커널 버전에 따라 기본 처리됨)
* `usrquota,grpquota,prjquota`

### 생성/점검/튜닝 도구

```bash
sudo mkfs.ext4 -L mydata -O metadata_csum,64bit /dev/sdX1
sudo e2fsck -f /dev/sdX1         # 일관성 검사(언마운트 상태에서)
sudo resize2fs /dev/sdX1         # 온라인/오프라인 확장(상황에 따라)
sudo tune2fs -l /dev/sdX1        # 슈퍼블록/기능 플래그 조회
sudo dumpe2fs -h /dev/sdX1       # 요약 정보(백업 슈퍼블록 위치 등)
sudo debugfs -R 'stat <2>' /dev/sdX1   # 루트 디렉터리 아이노드 조회
```

---

## 7) ASCII 다이어그램으로 보는 ext4 계층

### 온디스크 레이아웃(개략)

```
[ 파티션 /dev/sdX1 ]
┌───────────────────────────────────────────────────────────────┐
│ 0x000 ... 0x3FF : 부트코드/예약 영역                          │
│ 0x400 ...       : ┌───────────────────────────────────────┐  │
│ (1024 바이트)   │ 슈퍼블록(superblock)                    │  │
│                 └───────────────────────────────────────┘  │
│                 ┌───────────────────────────────────────┐  │
│                 │ 그룹 디스크립터 테이블(GDT)          │  │
│                 └───────────────────────────────────────┘  │
│  블록그룹 0     ┌─ 블록비트맵 ─┬─ 아이노드비트맵 ─┬─ 아이노드테이블 ─┬─ 데이터블록 ─┐
│  블록그룹 1     ├──────────────┼──────────────────┼───────────────────┼──────────────┤
│  블록그룹 2     ├──────────────┼──────────────────┼───────────────────┼──────────────┤
│  ...            └──────────────┴──────────────────┴───────────────────┴──────────────┘
└───────────────────────────────────────────────────────────────┘
```

### 파일 내부(아이노드 → 익스텐트 트리 → 데이터)

```
inode(#1234)
  └─ extent header (root)
       ├─ [내부노드…] (큰 파일일 때만)
       └─ [리프] : (논리오프셋 L0) → (물리시작 P0, 길이 len0)
                   (논리오프셋 L1) → (물리시작 P1, 길이 len1)
                   ...
```

### 디렉터리(이름 → 아이노드)와 htree

```
dir inode(#2 /)
  ├─ htree index block(s)  ← 이름 해시로 탐색
  └─ data block(s): [inode, rec_len, name_len, file_type, name...]
```

---

## 8) “ext4 정보가 블록장치 어디에 있나?” (요점 정리)

* **가장 핵심**은 **슈퍼블록**: **오프셋 1024바이트**부터 시작.
* ext4 마법값 **0xEF53**은 슈퍼블록 내부 **오프셋 0x38**에 위치.
* 슈퍼블록의 **백업본**은 선택된 **블록그룹**에 분산 저장(예: `sparse_super`, `sparse_super2`).
* **그룹 디스크립터**, **비트맵**, **아이노드 테이블**, **데이터 블록**이 **그룹 단위**로 배치.
* **저널**은 보통 \*\*내장 아이노드(#8)\*\*로 존재(또는 외장 장치).

---

## 9) 트러블슈팅·팁

* \*\*“파일시스템 타입 자동 인식”\*\*은 보통 `blkid`/커널이 슈퍼블록을 읽어 **매직/UUID/플래그**를 확인해서 이뤄집니다.
* **크래시 이후 부팅 지연**: `fsck`가 길어지면 `uninit_bg`, `metadata_csum` 활성화, 마운트 옵션(`noatime`, `lazytime`) 조정 고려.
* **SSD에서 TRIM**: 주기적 `fstrim.timer`(systemd) 활성화 or `fstrim -av`.
* **수십\~수백만 파일 디렉터리**: `dir_index` 확인(보통 기본 활성), 필요시 서브 디렉터리로 분할.
* **성능 병목**: `iostat`, `pidstat`, `perf`, `blktrace` 등으로 I/O 패턴을 먼저 측정.

---

## 10) 한 줄 요약

* ext4는 \*\*슈퍼블록 → 블록그룹(비트맵/아이노드/데이터) → 아이노드 → 익스텐트/디렉터리(htree)\*\*로 이어지는 **계층적 온디스크 구조**를 가지며,
* 리눅스는 여러 파일시스템을 **마운트**해 \*\*하나의 논리적 디렉터리 계층(FHS)\*\*로 보여줍니다.
* **지연 할당/멀티블록 할당/저널링(JBD2)/체크섬/64bit** 등으로 **성능과 일관성**을 함께 지향합니다.

---
