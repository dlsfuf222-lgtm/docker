# 리눅스의 `exec()` 시스템 호출: 프로세스를 덮어쓰기

---

## 1. `exec()`란 무엇인가?

리눅스에서 `exec()`는 **현재 실행 중인 프로세스를 새로운 프로그램으로 덮어쓰는 시스템 호출 계열**을 의미합니다.
즉, `fork()`가 새로운 **프로세스를 생성**하는 것이라면, `exec()`는 **프로세스의 내용을 교체**하는 것에 가깝습니다.

* **PID는 유지**된다.
* **메모리 공간, 코드, 데이터, 스택**은 새 프로그램으로 교체된다.
* **파일 디스크립터, 시그널 핸들러 일부, 환경 변수**는 그대로 유지되거나 지정된 규칙에 따라 초기화된다.

👉 프로세스를 완전히 새 이미지로 바꾸지만, 껍데기(PID)는 유지되는 셈입니다.

---

## 2. `exec()` 계열 함수들

리눅스에서는 사실 `exec()`라는 단일 함수는 없고, **여섯 가지 변형**이 있습니다:

| 함수                                    | 특징                       |
| ------------------------------------- | ------------------------ |
| `execl(path, arg0, arg1, …, NULL)`    | 인자를 리스트 형태로 직접 나열        |
| `execv(path, argv[])`                 | 인자를 `argv[]` 배열로 전달      |
| `execle(path, arg0, …, NULL, envp[])` | 환경 변수 배열(`envp`)까지 지정 가능 |
| `execve(path, argv[], envp[])`        | 가장 저수준 함수 (시스템콜)         |
| `execlp(file, arg0, …)`               | `PATH` 환경변수 기반 검색 지원     |
| `execvp(file, argv[])`                | `PATH` 검색 + 인자 배열 전달     |

📌 정리:

* `l` = list, `v` = vector(array), `p` = PATH 탐색, `e` = environment 지정
* 결국 **모두 `execve()`를 감싸는 편의 함수**입니다.

---

## 3. 기본 동작 순서

`exec()` 계열 호출이 성공하면:

1. **기존 프로세스 주소 공간 해제**

   * 텍스트, 데이터, 힙, 스택 영역 모두 사라짐
2. **새로운 프로그램 로드**

   * ELF(실행 파일 포맷)를 읽어 코드/데이터를 매핑
   * 초기 스택에 `argv`, `envp` 설정
3. **실행 시작**

   * 새 프로그램의 `main()` 또는 엔트리 포인트에서 실행 시작
   * 반환하지 않음 (실패 시에만 -1 반환)

---

## 4. 예제 코드

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("Before exec\n");

    char *args[] = { "ls", "-l", NULL };
    execvp("ls", args);

    // exec 성공 시 여기 도달하지 않음
    perror("exec failed");
    return 1;
}
```

### 실행 결과

```
Before exec
(total file list 출력...)
```

* `execvp("ls", args)` 호출 이후, 이 프로세스는 `ls`로 교체됨
* `printf("Before exec")`는 출력되지만, 그 이후 코드는 실행되지 않음

---

## 5. `fork()`와 `exec()`의 관계

* 보통 셸(bash, zsh 등)은 **`fork()`로 자식 프로세스 생성 → 자식이 `exec()`로 외부 프로그램 실행** 구조를 사용합니다.
* 이유: 셸 자신은 계속 살아있어야 하므로 `exec()`를 직접 호출하지 않고, 자식에게 실행을 위임합니다.

👉 예시 흐름:

```bash
$ ls
```

1. bash → `fork()` → 자식 프로세스 생성
2. 자식 → `execve("/bin/ls", …)` → `ls` 실행
3. 부모 bash는 `wait()`로 자식 종료 상태 수집
4. 프롬프트 복귀

---

## 6. 활용 사례

* **셸에서 외부 명령 실행**: bash가 `nc`, `ls`, `grep` 같은 커맨드를 실행할 때
* **서브프로세스 교체**: `fork()` 후 자식이 특정 명령으로 변신
* **데몬 구현**: 초기 프로세스가 `exec()`로 메인 서비스 실행
* **`exec` 셸 내장 명령**: 현재 셸을 종료하고 다른 프로그램으로 대체 (`exec bash`, `exec python`)

---

## 7. 주의할 점

* `exec()`가 성공하면 **호출한 프로세스의 기존 코드가 완전히 사라지므로, exec 이후 코드는 실행되지 않는다**.
* 실패 시에만 `-1` 반환되며, `errno`로 원인을 확인해야 한다.
* 파일 디스크립터는 기본적으로 그대로 유지되지만, `FD_CLOEXEC` 플래그가 설정된 FD는 닫힌다.
* 환경 변수(envp)는 명시적으로 넘기지 않으면 기존 환경이 상속된다.

---

## 8. 정리

* `fork()` = 프로세스 **복제**
* `exec()` = 프로세스 **교체**
* **셸 구조** = `fork()`로 자식 만들고, 자식이 `exec()`로 외부 명령 실행
* 따라서 `fork`와 `exec`는 항상 짝꿍처럼 다닌다.

---
