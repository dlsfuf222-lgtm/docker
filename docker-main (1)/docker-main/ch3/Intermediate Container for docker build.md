
Docker가 **Dockerfile을 기반으로 이미지를 빌드**할 때, 내부적으로는 각 명령어를 실행하기 위해 **임시 컨테이너(Intermediate Container)** 를 생성합니다.
이 컨테이너는 실제로 존재하지만 빌드 과정이 끝나면 자동으로 삭제됩니다.

---

## 1. Docker 빌드 과정의 기본 구조

`docker build` 명령을 실행하면 Docker는 다음 순서로 동작합니다.

1. **Dockerfile 파싱**:
   FROM, RUN, COPY 같은 명령어를 위에서부터 차례대로 읽음.

2인

## 1. 도커 이미지 빌드 파이프라인 요약

Dockerfile 빌드 과정은 다음처럼 동작합니다.

1. **FROM 단계**:

   * 베이스 이미지(예: `ubuntu:20.04`)를 컨테이너로 실행
   * 이 컨테이너는 첫 번째 임시 컨테이너가 됨
   * 실행 결과를 스냅샷으로 찍어 **첫 번째 레이어** 생성

2. **RUN 단계**:

   * 방금 만든 스냅샷을 기반으로 새로운 컨테이너 실행
   * 명령어(예: `apt-get update`) 실행
   * 결과 파일시스템 변경 내용을 새로운 스냅샷으로 저장 → **두 번째 레이어**

3. **COPY 단계**:

   * 또다시 임시 컨테이너 실행
   * 호스트의 파일을 컨테이너에 복사
   * 변경 내용을 커밋하여 **세 번째 레이어** 생성

4. 모든 명령어를 처리하고 나면 **마지막 임시 컨테이너는 제거**되고, 모든 레이어를 합친 최종 이미지가 생성됨.

---

## 2. 내부 동작 예시 (Dockerfile 기준)

예를 들어 다음 Dockerfile이 있을 때:

```dockerfile
FROM ubuntu:20.04
RUN apt-get update
COPY app.sh /app/app.sh
CMD ["/app/app.sh"]
```

`docker build .`를 실행하면 내부적으로 이런 식으로 처리됩니다:

| 단계 | 실행되는 임시 컨테이너         | 수행 작업               | 생성 결과             |
| -- | -------------------- | ------------------- | ----------------- |
| 1  | ubuntu:20.04 기반 컨테이너 | 아무 작업 없음            | 레이어1 (베이스 이미지)    |
| 2  | 레이어1 기반 컨테이너         | `apt-get update` 실행 | 레이어2 (패키지 인덱스 갱신) |
| 3  | 레이어2 기반 컨테이너         | `app.sh` 복사         | 레이어3 (앱 코드 포함)    |
| 4  | 레이어3 기반 컨테이너         | CMD 설정 (메타데이터만)     | 레이어4 (메타데이터)      |

마지막에 **임시 컨테이너는 삭제되고** 레이어들의 스냅샷만 남아 최종 이미지가 완성됩니다.

---

## 3. 확인 방법

`docker build` 명령어에 `--progress=plain --no-cache` 옵션을 주면
빌드 과정에서 각 명령어 실행 시 컨테이너가 만들어지고 삭제되는 과정을 직접 확인할 수 있습니다.

```bash
docker build --progress=plain --no-cache -t myapp:latest .
```

출력에서 보통 이런 식으로 나옵니다:

```
#1 [1/4] FROM ubuntu:20.04
#2 [2/4] RUN apt-get update
#3 [3/4] COPY app.sh /app/app.sh
#4 [4/4] CMD ["/app/app.sh"]
```

---

## 4. 핵심 요약

* **각 명령어 → 새로운 임시 컨테이너 → 레이어 생성 → 컨테이너 제거**
* 이렇게 생성된 레이어는 캐시되어 다음 빌드에서 재사용 가능
* 불필요한 임시 컨테이너는 빌드 완료 시 자동 삭제

---
